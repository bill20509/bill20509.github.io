[{"content":"Concept  Brute force\n看到 length \u0026lt; 12 Dynamic Programming Bitmask  Steps 參考自votrubac\n先將所有可能的sequence 以 1~4096表示 (因為字串最長到12)\n並檢查是否其為回文\n是的話 dp[i] = 回文長度\n否的話 dp[i] = 0\n然後，檢查其反數的所有子序列\n則 ans = dp[i] * dp[j], i, j disjiont.\n例如:\n10001\n01110 =\u0026gt; 找其子序列\nhttps://cp-algorithms.com/algebra/all-submasks.html\n心得 一開始有想到bitmask, 也想到用暴力法把所有可能記錄下來, 但找反數的所有子序列不知道為啥就卡死了。\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  class Solution { public: int pali_length(string \u0026amp;s, int mask) { int l = 0; int r = s.size(); int res = 0; while(l \u0026lt;= r) { if((mask \u0026amp; (1 \u0026lt;\u0026lt; l)) == 0) { l++; } else if((mask \u0026amp; (1 \u0026lt;\u0026lt; r)) == 0) { r--; } else if(s[l] != s[r]) { return 0; } else{ res = (res + 1 + (l == r? 0:1)); l++; r--; } } return res; } int maxProduct(string s) { int res = 0, n = s.size(), mask = (1 \u0026lt;\u0026lt; n) - 1; int dp[4096] = {}; for(int i = 1; i \u0026lt;= mask; i++) { dp[i] = pali_length(s, i); // if(dp[i] == 3)cout \u0026lt;\u0026lt; dp[i] \u0026lt;\u0026lt; endl;  } for(int i = mask; i; i--) { if(dp[i] * (n - dp[i]) \u0026gt; res) { for(int j = mask ^ i; j; j = (j - 1) \u0026amp; (mask ^ i) ) { res = max(res, dp[j] * dp[i]); } } } return res; } };   ","description":"Leetcode 2002","id":0,"section":"posts","tags":["leetcode","dynamic programming"],"title":"Leetcode 2002 Maximum Product of the Length of Two Palindromic Subsequences","uri":"https://bill20509.github.io/posts/leetcode_2002/"},{"content":"Concept 參考自神奇的Lee215\n類似Leetcode Meeting Room\n記錄每個start, end作為斷點\n每個斷點記錄他的變化值(delta)\nstart就加、end就減\n最後遍歷每個斷點，即可得到答案。\n圖片來自:FishballLin\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution { public: vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; splitPainting(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; segments) { map\u0026lt;int, long long\u0026gt; m; for(int i = 0; i \u0026lt; segments.size(); i++){ m[segments[i][0]] += segments[i][2]; m[segments[i][1]] -= segments[i][2]; } vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; res; int curr = 0; for(auto it: m){ if(m[curr] \u0026gt; 0){ res.push_back({curr, it.first, m[curr]}); } m[it.first] += m[curr]; curr = it.first; } return res; } };   ","description":"Leetcode 1943","id":1,"section":"posts","tags":["leetcode","line sweep"],"title":"Leetcode 1943. Describe the Painting","uri":"https://bill20509.github.io/posts/leetcode_1943/"},{"content":"Concept 先說結論:\n1.Backtracking\n2.Permutation\n1.Backtracking 因為看到Constraints: 1 \u0026lt;= m, n \u0026lt;= 8\n在比賽當下第一個想到的是用backtracking\n計算次數: m*m*n\n先把所有的可能算出存到一個table(避免在backtracking時重複計算)\n(這畫圖技術\u0026hellip;)\n那這樣就可以把此問題轉為一個類似N-queens的問題\n找出所有路徑並把所有答案記錄下來，算出最大值\n2.Permutation 透過Backtracking觀察\n我們可以發現所有路徑就是 0 ~ n-1 的permutation\n一樣透過存值到table\n將這些路徑全部算出即可得到答案\nhints: C++ \u0026lt;alogrithm\u0026gt;中有個next_permutation可以用\nCode Backtracking Runtime: 52 ms,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class Solution { public: int ans = INT_MIN; int bit_count(vector\u0026lt;int\u0026gt;\u0026amp; a, vector\u0026lt;int\u0026gt;\u0026amp; b){ int count = 0; for(int i = 0; i \u0026lt; a.size(); i++){ if(a[i] == b[i]){ count++; } } return count; } void helper(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; s, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; m, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; table, vector\u0026lt;bool\u0026gt;\u0026amp; visited, int pos, int count){ if(pos == s.size()){ ans = max(ans, count); return; } for(int i = 0; i \u0026lt; table.size(); i++){ if(visited[i]){ visited[i] = false; helper(s, m, table, visited, pos + 1, count + table[pos][i]); visited[i] = true; } } } int maxCompatibilitySum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; students, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mentors) { int bits = students[0].size(); int n = students.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; table(n, vector\u0026lt;int\u0026gt;(n, 0)); for(int i = 0; i \u0026lt; n; i++){ for(int j = 0; j \u0026lt; n; j++){ table[i][j] = bit_count(students[i], mentors[j]); } } vector\u0026lt;bool\u0026gt; visited(n, true); helper(students, mentors, table, visited, 0, 0); return ans; } };   Permutation without pre-calculate table Runtime: 384 ms\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { public: int maxCompatibilitySum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; students, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mentors) { int ans = 0; vector\u0026lt;int\u0026gt; list; int n = students.size(); int m = students[0].size(); for(int i = 0; i \u0026lt; n; i++) { list.push_back(i); } do{ int count = 0; for(int i = 0; i \u0026lt; n; i++){ for(int j = 0; j \u0026lt; m; j++){ if(students[i][j] == mentors[list[i]][j]){ count ++; } } } ans = max(ans, count); }while(next_permutation(list.begin(), list.end())); return ans; } };   Permutation with pre-calculate table Runtime: 52ms\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  class Solution { public: int bit_count(vector\u0026lt;int\u0026gt;\u0026amp; a, vector\u0026lt;int\u0026gt;\u0026amp; b){ int count = 0; for(int i = 0; i \u0026lt; a.size(); i++){ if(a[i] == b[i]){ count++; } } return count; } int maxCompatibilitySum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; students, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mentors) { int ans = 0; vector\u0026lt;int\u0026gt; list; int n = students.size(); int m = students[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; table(n, vector\u0026lt;int\u0026gt;(n, 0)); for(int i = 0; i \u0026lt; n; i++){ for(int j = 0; j \u0026lt; n; j++){ table[i][j] = bit_count(students[i], mentors[j]); } } for(int i = 0; i \u0026lt; n; i++) { list.push_back(i); } do{ int count = 0; for(int i = 0; i \u0026lt; n; i++){ count += table[i][list[i]]; } ans = max(ans, count); }while(next_permutation(list.begin(), list.end())); return ans; } };   ","description":"Leetcode 1947","id":2,"section":"posts","tags":["leetcode","backtracking"],"title":"Leetcode 1947. Maximum Compatibility Score Sum","uri":"https://bill20509.github.io/posts/leetcode_1947/"},{"content":"Concept 雖然是Hard，但其實概念不難，難度介於medium~hard，比較要小心的是可能要先做預處理，不然有可能TLE。\n在做本題前可以先參考1411. Number of Ways to Paint N × 3 Grid，基本上是一樣的概念 。\n每一row都是一個狀態，我們只需要從row[1]開始，記錄對於前一row的狀態中所有的可能，最後再將row[n]所的狀態做加總，即可得到答案。\nSteps Step 1: 記錄每一row合法的所有組合 先假設m = 5, 我們預處理每一row的可能組合，就是3^5種，那在這3^5之中又有多少合法的組合呢?\n可以用簡單的暴力法求出，並存在vector\u0026lt;int\u0026gt; type中。\n如何儲存?\n3^5種的話，我們用三進位去代表填色的情況\n例如:\n120,010, 130\u0026hellip; 都代表合法的塡色情況。\nStep 2: 在組合中求出關係 在vector\u0026lt;int\u0026gt; type中，我們可以枚舉出所有type[i]與type[j]的關係\n如果type[i]與type[j]合法，則存在 related[i][j] = 1 \nStep 3: DP 因為row[1]可以填入任何type，所以dp[1][0~type_cnt] = 1 \n我們再分別對row[1~n]做處理即可。\ndp[i][j] += dp[i-1][k], k ∈ related[i][k] = 1\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  class Solution { public: int colorTheGrid(int m, int n) { vector\u0026lt;int\u0026gt; type; // step 1  for(int i = 0; i \u0026lt; pow(3, m); i++){ int prev = -1; int temp = i; for(int j = 0; j \u0026lt; m; j++){ int curr = temp % 3; if(prev == curr) break; prev = curr; temp /= 3; if(temp == 0 \u0026amp;\u0026amp; j == m - 1){ type.push_back(i); } } } // step 2  int type_cnt = type.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; related(type_cnt, vector\u0026lt;int\u0026gt;(type_cnt)); for(int i = 0; i \u0026lt; type_cnt; i++){ for(int j = 0; j \u0026lt; type_cnt; j++){ int temp_a = type[i]; int temp_b = type[j]; for(int k = 0; k \u0026lt; m; k++){ if(temp_a % 3 == temp_b % 3){ break; } temp_a /= 3; temp_b /= 3; if(k == m - 1){ related[i][j] = 1; } } } } // step3  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;int\u0026gt;(type_cnt)); for(int i = 0; i \u0026lt; type_cnt; i++){ dp[1][i] = 1; } for(int i = 2; i \u0026lt;= n; i++){ for(int j = 0; j \u0026lt; type_cnt; j++){ for(int k = 0; k \u0026lt; type_cnt; k++){ if(related[j][k]){ dp[i][j] += dp[i-1][k]; dp[i][j] %= 1000000007; } } } } int count = 0; for(int i = 0; i \u0026lt; type_cnt; i++){ count += dp[n][i]; count %= 1000000007; } return count; } };   ","description":"LeetCode 1931","id":3,"section":"posts","tags":["leetcode","dynamic programming"],"title":"LeetCode 1931. Painting a Grid With Three Different Colors","uri":"https://bill20509.github.io/posts/leetcode_1931/"},{"content":"關於我  性別 : 男 年齡 : 24 職稱 : Engineer 學歷 : 國立中山大學資訊工程學系 Email : maxbill20509@gmail.com  個人興趣  後端有關的任何技術 CI/CD、自動化部屬、測試 音樂/爵士鼓  ","description":"Introduction","id":4,"section":"","tags":null,"title":"","uri":"https://bill20509.github.io/about/"},{"content":"Fault, Error \u0026amp; Failure  在軟體與硬體中都有Fault, Error \u0026amp; Failure，此處我們只討論軟體  Software Fault  A static defect in the software(i.e., defect) 靜態存在於code中的錯誤  Software Error  An incorrect internal state that is the manifestation of some faults 由fault觸發的錯誤中間狀態  Software Failure  External, incorrect behavior with respect to the requirements of othere description of the expected behavior 由Error所傳播出去，使測試人員或使用者所觀測到的失效行為  實例  說明 - 給定input numbers, 算出平均值 Fault - i的初始值誤設為1(應為0) Error - sum誤算為4+5 (應為3+4+5) Failure - mean誤算為3 (應為3)  PIE Model  首字母P、I、E所組成 只有達成下面三項，才會得到failure  Execution/Reachability -\u0026gt; Fault  The location or lcations in the program that contain the fault must be reached 測試必須執行到fault的位置  Infection -\u0026gt; Error  The state of the program must be incorrect 即使執行到fault的位置，也不一定會觸發Error  此例中，即使執行到了fault，但碰巧地沒有觸發error，最終的結果也是正確  Propagation -\u0026gt; Failure  The infected state must propagate to cause some output of the program to be incorrect 即使執行到了fault，觸發了error，也可能沒有failure  Fault - length長度錯誤值 number.length-1 (應為number.length) Error - sum值計算錯誤3+5(應為3+5+4) Failure - 然後最終碰巧地沒有Failure  Quiz  Is there is a fault, which cannot be revealed by any test? Is it a fault or not a fault? 我的見解是，這不算fault，因為唯有被測試出來，才能稱之為fault，雞生蛋、蛋生雞的概念  Exercise  Please constrct a simple program P(with a fault) and 3 tests(t1, t2, t3), s.t.  t1 executes the fault, but no error t2 (executes the fault and) produces an error, but no failure t3 produces a failure    1 2 3 4 5 6 7 8 9 10 11  string string_reverse(string input){ int length = input.length() - 2; int i = 1; int j = length; while(i \u0026lt; j) { swap(input[i], input[j]); i++; j--; } return input; }    tests(t1, t2, t3)  t1 = t2 = t3 =    ","description":"Fault、Error、Failure以及PIE Model的介紹","id":5,"section":"posts","tags":["testing","terminology"],"title":"PIE Model","uri":"https://bill20509.github.io/posts/pie_model/"},{"content":"Test Case  一個Test Case包含Test Input(測試輸入)、Test Oracle(預期輸出)、Enivironment(測試環境) 有時test case等於test input，端看如何定義 需要描述test case的環境  Testing vs. Debugging  Testing是執行test case並找出failure Debugging則是定位處fault並矯正fault  Validation vs. Verification Validation  確認SPEC符合客戶的需求  Verification  確認SPEC與實現是否一致  靜/動態測試 Static Testing  without excuting programs 嚴格來講不算測試  Dynamic Testing  with excuting programgs 大部分討論的都是動態測試  黑/白盒測試 Black-box Testing  without source code 在測試中不需要知道內部的結構  White-box Testing  with source code 需要原始碼，去分析可能出現的問題  灰盒測試?  錯誤 - 白盒+黑盒測試 正確 - 指透過其他程式或反編譯，獲得部分訊息，進而進行測試 例子 - 在android中，透過反編譯得到結構訊息進行測試  Testing Level  這些level定義的範圍是模糊的、非標準化，在不同公司可能有不同定義 在Google中分為小、中、大測試 Google軟件測試之道  V-Model  需求、設計、Coding、測試的流程 由於現今的開發流程快速，這個模型可能已不大適用  測試過程 資料來源 V-Model\n南京大學軟件測試課程\n","description":"測試相關名詞解釋","id":6,"section":"posts","tags":["testing","terminology"],"title":"Testing Terminology","uri":"https://bill20509.github.io/posts/terminology/"}]